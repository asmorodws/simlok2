generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/// ----------  USER  ----------
model User {
  id                       String             @id @default(cuid())
  email                    String             @unique
  password                 String
  role                     User_role          @default(VENDOR)
  position                 String?            // for approver position
  address                  String?
  created_at               DateTime           @default(now())
  profile_photo            String?
  officer_name             String
  vendor_name              String?
  phone_number             String?
  verified_at              DateTime?
  verified_by              String?
  isActive                 Boolean            @default(true)
  lastActiveAt             DateTime?
  sessionExpiry            DateTime?
  rejected_at              DateTime?
  rejected_by              String?
  rejection_reason         String?
  verification_status      VerificationStatus @default(PENDING)

  qrScans                  QrScan[]           @relation("QrScannedBy")
  refreshTokens            RefreshToken[]
  sessions                 Session[]
  finalApprovedSubmissions Submission[]       @relation("FinalApprovedSubmissions")
  submissions              Submission[]
}

/// ----------  REFRESH TOKEN  ----------
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "RefreshToken_userId_fkey")
}

/// ----------  NEXTAUTH LEGACY (bisa dihapus jika tidak dipakai)  ----------


model Session {
  id             String    @id @default(cuid())
  sessionToken   String    @unique
  userId         String
  expires        DateTime
  createdAt      DateTime  @default(now())
  lastActivityAt DateTime  @default(now())
  ipAddress      String?
  userAgent      String?   @db.Text
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Session_userId_fkey")
  @@index([expires], map: "Session_expires_idx")
  @@index([lastActivityAt], map: "Session_lastActivityAt_idx")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/// ----------  SUBMISSION  ----------
model Submission {
  id                        String       @id @default(cuid())
  reviewed_by               String?
  approved_by               String?
  vendor_name               String
  based_on                  String
  officer_name              String
  job_description           String
  work_location             String       @db.Text
  implementation            String?      @db.Text
  working_hours             String
  holiday_working_hours     String?
  work_facilities           String       @db.Text
  
  // simja_number              String?
  // simja_date                DateTime?
  // sika_number               String?
  // sika_date                 DateTime?
  // sika_document_upload      String?
  // simja_document_upload     String?
  // simja_type               String?
  // sika_type                 String?
  
  simlok_number             String?      @unique
  simlok_date               DateTime?

  // HSSE PASS
  // hsse_pass_document_upload String?
  // hsse_pass_number          String?
  // hsse_pass_valid_thru     DateTime?
  
  worker_names              String       @db.Text
  content                   String?      @db.Text
  qrcode                    String?      @db.LongText
  created_at                DateTime     @default(now())
  user_id                   String?      // Made optional for deleted users
  // Denormalized user data - preserved when user is deleted
  user_email                String?
  user_officer_name         String?
  user_vendor_name          String?
  user_phone_number         String?
  user_address              String?
  signer_position           String?
  signer_name               String?
  implementation_end_date   DateTime?
  implementation_start_date DateTime?
  approved_at               DateTime?
  approved_by_final_id      String?
  note_for_vendor           String?      @db.Text
  approval_status           ApprovalStatus  @default(PENDING_APPROVAL)
  note_for_approver         String?      @db.Text
  review_status             ReviewStatus @default(PENDING_REVIEW)
  reviewed_at               DateTime?
  worker_count              Int?
  vendor_phone              String?
  qrScans                   QrScan[]     @relation("SubmissionQrScans")
  approved_by_final_user    User?        @relation("FinalApprovedSubmissions", fields: [approved_by_final_id], references: [id], onDelete: SetNull)
  user                      User?        @relation(fields: [user_id], references: [id], onDelete: SetNull)
  worker_list               WorkerList[]
  support_documents         SupportDocument[]

  // Performance indexes
  @@index([review_status])
  @@index([approval_status])
  @@index([created_at])
  @@index([approved_by_final_id])
  @@index([user_id], map: "Submission_user_id_perf_idx")              // For vendor filtering
  @@index([vendor_name], map: "Submission_vendor_name_search_idx")    // For vendor search
  @@index([review_status, approval_status], map: "Submission_review_approval_compound_idx") // Compound index for approver queries
}

/// ----------  WORKER LIST  ----------
model WorkerList {
  id            String     @id @default(cuid())
  worker_name   String
  worker_photo  String?
  hsse_pass_number String?
  hsse_pass_valid_thru DateTime?
  hsse_pass_document_upload String?
  submission_id String
  created_at    DateTime   @default(now())
  submission    Submission @relation(fields: [submission_id], references: [id], onDelete: Cascade)

  @@index([submission_id])
}

//// ------------ Support Document ---------
model SupportDocument {
  id              String     @id @default(cuid())
  document_type   String?
  document_subtype String?
  document_number String?
  document_date   DateTime?
  document_upload String
  submission_id   String
  uploaded_at     DateTime   @default(now())
  uploaded_by     String
  submission      Submission @relation(fields: [submission_id], references: [id], onDelete: Cascade)
  @@index([uploaded_by])
} 

/// ----------  NOTIFICATION  ----------
model Notification {
  id         String             @id @default(cuid())
  scope      NotificationScope
  vendor_id  String?
  type       String
  title      String
  message    String             @db.Text
  data       String?            @db.LongText
  created_at DateTime           @default(now())
  reads      NotificationRead[]

  @@index([scope, vendor_id, created_at])
}

model NotificationRead {
  id              String       @id @default(cuid())
  notification_id String
  user_id         String?
  vendor_id       String?
  read_at         DateTime     @default(now())
  notification    Notification @relation(fields: [notification_id], references: [id], onDelete: Cascade)

  @@unique([notification_id, user_id])
  @@unique([notification_id, vendor_id])
  @@index([user_id])
  @@index([vendor_id])
}



/// ----------  QR SCAN TRACKING  ----------
model QrScan {
  id            String     @id @default(cuid())
  submission_id String
  scanned_by    String
  scanned_at    DateTime   @default(now())
  scanner_name  String?
  scan_location String?
  user          User       @relation("QrScannedBy", fields: [scanned_by], references: [id], onDelete: Cascade)
  submission    Submission @relation("SubmissionQrScans", fields: [submission_id], references: [id], onDelete: Cascade)

  @@index([submission_id])
  @@index([scanned_by])
  @@index([scanned_at])
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum ReviewStatus {
  PENDING_REVIEW
  MEETS_REQUIREMENTS
  NOT_MEETS_REQUIREMENTS
}

enum ApprovalStatus {
  PENDING_APPROVAL
  APPROVED
  REJECTED
  NEEDS_REVISION  // Submission needs to be fixed by vendor based on reviewer feedback
}

enum NotificationScope {
  admin
  vendor
  reviewer
  approver
}

enum User_role {
  VENDOR
  VERIFIER
  SUPER_ADMIN
  REVIEWER
  APPROVER
  VISITOR
}
