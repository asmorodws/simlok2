generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/// ----------  USER  ----------
model User {
  id                       String             @id @default(cuid())
  email                    String             @unique
  password                 String
  role                     User_role          @default(VENDOR)
  position                 String?            // for approver position
  address                  String?
  created_at               DateTime           @default(now())
  profile_photo            String?
  officer_name             String
  vendor_name              String?
  phone_number             String?
  verified_at              DateTime?
  verified_by              String?
  isActive                 Boolean            @default(true)
  lastActiveAt             DateTime?
  sessionExpiry            DateTime?
  rejected_at              DateTime?
  rejected_by              String?
  rejection_reason         String?
  verification_status      VerificationStatus @default(PENDING)

  qrScans                  QrScan[]           @relation("QrScannedBy")
  refreshTokens            RefreshToken[]
  sessions                 Session[]
  finalApprovedSubmissions Submission[]       @relation("FinalApprovedSubmissions")
  submissions              Submission[]
  
  // Performance indexes for dashboard stats
  @@index([verification_status, created_at])
  @@index([role, verified_at])
}

/// ----------  REFRESH TOKEN  ----------
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "RefreshToken_userId_fkey")
}

/// ----------  NEXTAUTH LEGACY (bisa dihapus jika tidak dipakai)  ----------


model Session {
  id             String    @id @default(cuid())
  sessionToken   String    @unique
  userId         String
  expires        DateTime
  createdAt      DateTime  @default(now())
  lastActivityAt DateTime  @default(now())
  ipAddress      String?
  userAgent      String?   @db.Text
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Session_userId_fkey")
  @@index([expires], map: "Session_expires_idx")
  @@index([lastActivityAt], map: "Session_lastActivityAt_idx")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/// ----------  SUBMISSION  ----------
model Submission {
  id                        String       @id @default(cuid())
  reviewed_by               String?
  approved_by               String?
  vendor_name               String
  based_on                  String
  officer_name              String
  job_description           String
  work_location             String
  implementation            String?      @db.Text
  working_hours             String
  holiday_working_hours     String?
  work_facilities           String
  
  // simja_number              String?
  // simja_date                DateTime?
  // sika_number               String?
  // sika_date                 DateTime?
  // sika_document_upload      String?
  // simja_document_upload     String?
  // simja_type               String?
  // sika_type                 String?
  
  simlok_number             String?
  simlok_date               DateTime?

  // HSSE PASS
  // hsse_pass_document_upload String?
  // hsse_pass_number          String?
  // hsse_pass_valid_thru     DateTime?
  
  worker_names              String       @db.Text
  content                   String?      @db.Text
  qrcode                    String?      @db.LongText
  created_at                DateTime     @default(now())
  user_id                   String?      // Made optional for deleted users
  // Denormalized user data - preserved when user is deleted
  user_email                String?
  user_officer_name         String?
  user_vendor_name          String?
  user_phone_number         String?
  user_address              String?
  signer_position           String?
  signer_name               String?
  implementation_end_date   DateTime?
  implementation_start_date DateTime?
  approved_at               DateTime?
  approved_by_final_id      String?
  note_for_vendor           String?      @db.Text
  approval_status           ApprovalStatus  @default(PENDING_APPROVAL)
  note_for_approver         String?      @db.Text
  review_status             ReviewStatus @default(PENDING_REVIEW)
  reviewed_at               DateTime?
  worker_count              Int?
  vendor_phone              String?
  qrScans                   QrScan[]     @relation("SubmissionQrScans")
  approved_by_final_user    User?        @relation("FinalApprovedSubmissions", fields: [approved_by_final_id], references: [id], onDelete: SetNull)
  user                      User?        @relation(fields: [user_id], references: [id], onDelete: SetNull)
  worker_list               WorkerList[]
  support_documents         SupportDocument[]

  // Performance indexes
  @@index([review_status])
  @@index([approval_status])
  @@index([created_at])
  @@index([approved_by_final_id])
  @@index([user_id], map: "Submission_user_id_perf_idx")              // For vendor filtering
  @@index([vendor_name], map: "Submission_vendor_name_search_idx")    // For vendor search
  @@index([review_status, approval_status], map: "Submission_review_approval_compound_idx") // Compound index for approver queries
  
  // Additional performance indexes for common queries
  @@index([user_id, created_at], map: "Submission_user_created_idx")  // For vendor submission history with sorting
  @@index([user_id, approval_status], map: "Submission_user_status_idx") // For vendor filtering by status
  @@index([approval_status, created_at], map: "Submission_status_created_idx") // For admin/reviewer list with sorting
  @@index([review_status, created_at], map: "Submission_review_created_idx") // For reviewer workflow
  @@index([simlok_number], map: "Submission_simlok_number_idx")       // For SIMLOK number lookup
  @@index([approved_at], map: "Submission_approved_at_idx")           // For approval date filtering
  @@index([reviewed_at], map: "Submission_reviewed_at_idx")           // For review date filtering
  @@index([implementation_start_date], map: "Submission_impl_start_idx") // For implementation date range queries
  @@index([implementation_end_date], map: "Submission_impl_end_idx")   // For implementation date range queries
  @@index([vendor_name, created_at], map: "Submission_vendor_created_idx") // For vendor search with sorting
  @@index([officer_name], map: "Submission_officer_name_idx")         // For officer name search
  @@index([job_description], map: "Submission_job_desc_idx")          // For job description search
}

/// ----------  WORKER LIST  ----------
model WorkerList {
  id            String     @id @default(cuid())
  worker_name   String
  worker_photo  String?
  hsse_pass_number String?
  hsse_pass_valid_thru DateTime?
  hsse_pass_document_upload String?
  submission_id String
  created_at    DateTime   @default(now())
  submission    Submission @relation(fields: [submission_id], references: [id], onDelete: Cascade)

  @@index([submission_id])
  @@index([worker_name], map: "WorkerList_worker_name_idx") // For worker name search
  @@index([hsse_pass_number], map: "WorkerList_hsse_number_idx") // For HSSE pass lookup
  @@index([submission_id, created_at], map: "WorkerList_submission_created_idx") // For ordered worker list
}

//// ------------ Support Document ---------
model SupportDocument {
  id              String     @id @default(cuid())
  document_type   String?
  document_subtype String?
  document_number String?
  document_date   DateTime?
  document_upload String
  submission_id   String
  uploaded_at     DateTime   @default(now())
  uploaded_by     String
  submission      Submission @relation(fields: [submission_id], references: [id], onDelete: Cascade)
  
  @@index([submission_id]) // For fetching all documents for a submission
  @@index([uploaded_by])
  @@index([document_type], map: "SupportDocument_type_idx") // For filtering by document type
  @@index([document_subtype], map: "SupportDocument_subtype_idx") // For filtering by document subtype
  @@index([submission_id, uploaded_at], map: "SupportDocument_submission_uploaded_idx") // For ordered document list
  @@index([document_number], map: "SupportDocument_number_idx") // For document number lookup
} 

/// ----------  NOTIFICATION  ----------
model Notification {
  id         String             @id @default(cuid())
  scope      NotificationScope
  vendor_id  String?
  type       String
  title      String
  message    String             @db.Text
  data       String?            @db.LongText
  created_at DateTime           @default(now())
  reads      NotificationRead[]

  @@index([scope, vendor_id, created_at])
  @@index([type], map: "Notification_type_idx") // For filtering by notification type
  @@index([created_at], map: "Notification_created_at_idx") // For sorting by date
  @@index([vendor_id, created_at], map: "Notification_vendor_created_idx") // For vendor notification list
}

model NotificationRead {
  id              String       @id @default(cuid())
  notification_id String
  user_id         String?
  vendor_id       String?
  read_at         DateTime     @default(now())
  notification    Notification @relation(fields: [notification_id], references: [id], onDelete: Cascade)

  @@unique([notification_id, user_id])
  @@unique([notification_id, vendor_id])
  @@index([user_id])
  @@index([vendor_id])
  @@index([user_id, read_at], map: "NotificationRead_user_read_idx") // For user notification history
  @@index([notification_id, user_id], map: "NotificationRead_notif_user_idx") // For checking read status
}



/// ----------  QR SCAN TRACKING  ----------
model QrScan {
  id            String     @id @default(cuid())
  submission_id String
  scanned_by    String
  scanned_at    DateTime   @default(now())
  scanner_name  String?
  scan_location String?
  user          User       @relation("QrScannedBy", fields: [scanned_by], references: [id], onDelete: Cascade)
  submission    Submission @relation("SubmissionQrScans", fields: [submission_id], references: [id], onDelete: Cascade)

  @@index([submission_id])
  @@index([scanned_by])
  @@index([scanned_at])
  @@index([submission_id, scanned_at], map: "QrScan_submission_scanned_idx") // For submission scan history
  @@index([scanned_by, scanned_at], map: "QrScan_user_scanned_idx") // For user scan activity
  @@index([scan_location], map: "QrScan_location_idx") // For scan location filtering
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum ReviewStatus {
  PENDING_REVIEW
  MEETS_REQUIREMENTS
  NOT_MEETS_REQUIREMENTS
}

enum ApprovalStatus {
  PENDING_APPROVAL
  APPROVED
  REJECTED
}

enum NotificationScope {
  admin
  vendor
  reviewer
  approver
}

enum User_role {
  VENDOR
  VERIFIER
  SUPER_ADMIN
  REVIEWER
  APPROVER
  VISITOR
}
