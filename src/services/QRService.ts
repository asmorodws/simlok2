/**
 * QR Service
 * Business logic for QR code verification and scanning
 * Handles QR/Barcode validation, duplicate detection, scan logging
 */

import { prisma } from '@/lib/singletons';
import { logger } from '@/lib/logger';
import { parseQrString, type QrPayload } from '@/lib/qr-security';
import { toJakartaISOString } from '@/lib/timezone';

// ==================== TYPE DEFINITIONS ====================

export interface VerifyQRData {
  qrString: string;
  scannedBy: string;
  scannerType?: 'CAMERA' | 'BARCODE_SCANNER' | 'MANUAL';
  scanLocation?: string;
}

export interface QRVerificationResult {
  success: boolean;
  message?: string;
  error?: string;
  submission?: any;
  previousScan?: any;
}

// ==================== QR SERVICE ====================

export class QRService {
  /**
   * Verify QR code and return submission data
   */
  static async verifyQR(data: VerifyQRData): Promise<QRVerificationResult> {
    try {
      const { qrString, scannedBy, scannerType = 'CAMERA', scanLocation } = data;

      logger.info('QRService', 'QR verification started', {
        qrStringLength: qrString?.length,
        scannedBy,
        scannerType,
      });

      // Parse and verify QR code or barcode
      const qrPayload: QrPayload | null = parseQrString(qrString);
      
      if (!qrPayload) {
        logger.warn('QRService', 'Failed to parse QR/Barcode', { qrString });
        return {
          success: false,
          message: 'Invalid QR code/barcode or data has been tampered with. Please make sure you are scanning a valid SIMLOK QR code or barcode generated by the system.'
        };
      }

      // Check QR expiration (7 days validity)
      const now = Date.now();
      if (qrPayload.timestamp && now > qrPayload.timestamp + (7 * 24 * 60 * 60 * 1000)) {
        return {
          success: false,
          message: 'QR code/barcode has expired. Please generate a new one.'
        };
      }

      // Fetch submission with all relations
      const submission = await prisma.submission.findUnique({
        where: { id: qrPayload.id },
        include: {
          user: {
            select: {
              id: true,
              officer_name: true,
              email: true,
              vendor_name: true,
            }
          },
          worker_list: {
            select: {
              id: true,
              worker_name: true,
              worker_photo: true,
            },
            orderBy: {
              created_at: 'asc'
            }
          }
        }
      });

      if (!submission) {
        return {
          success: false,
          message: 'Submission not found'
        };
      }

      // Check if submission is approved
      if (submission.approval_status !== 'APPROVED') {
        return {
          success: false,
          message: 'This submission is not approved yet'
        };
      }

      // Verify scanned_by user exists
      const userExists = await prisma.user.findUnique({
        where: { id: scannedBy },
        select: { id: true, email: true, role: true, officer_name: true, address: true }
      });
      
      if (!userExists) {
        logger.error('QRService', 'Scanner user not found in database', { scannedBy });
        return {
          success: false,
          message: 'User session is invalid. Please login again.'
        };
      }

      // Check for duplicate scans - same verifier, same submission, same day
      const existingTodayScan = await this.checkDuplicateScanToday(qrPayload.id, scannedBy);
      
      if (existingTodayScan) {
        const scanDate = new Date(existingTodayScan.scanned_at);
        const formattedDate = scanDate.toLocaleDateString('id-ID', {
          day: '2-digit',
          month: '2-digit', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        return {
          success: false,
          error: 'duplicate_scan_same_day',
          message: `QR code sudah anda scan hari ini pada ${formattedDate}. Satu verifikator hanya dapat melakukan scan sekali per hari untuk SIMLOK yang sama.`,
          previousScan: {
            scanDate: existingTodayScan.scanned_at,
            scanId: existingTodayScan.id,
            verifierName: existingTodayScan.user?.officer_name,
          }
        };
      }

      // Record the scan
      const qrScan = await prisma.qrScan.create({
        data: {
          submission_id: submission.id,
          scanned_by: scannedBy,
          scanned_at: new Date(),
          scanner_name: userExists.officer_name || 'Unknown',
          scan_location: scanLocation || userExists.address || 'Unknown location',
        }
      });

      logger.info('QRService', 'QR scan recorded', {
        submissionId: submission.id,
        scanId: qrScan.id,
        scannedBy,
      });

      // Format response with Jakarta timezone
      const formattedSubmission = {
        ...submission,
        created_at: toJakartaISOString(submission.created_at) || submission.created_at,
        implementation_start_date: toJakartaISOString(submission.implementation_start_date) || submission.implementation_start_date,
        implementation_end_date: toJakartaISOString(submission.implementation_end_date) || submission.implementation_end_date,
        reviewed_at: toJakartaISOString(submission.reviewed_at) || submission.reviewed_at,
        approved_at: toJakartaISOString(submission.approved_at) || submission.approved_at,
        scanInfo: {
          scanId: qrScan.id,
          scannedAt: toJakartaISOString(qrScan.scanned_at) || qrScan.scanned_at,
          scannedBy: userExists.officer_name,
          scannerType: scannerType,
          scanLocation: qrScan.scan_location,
        }
      };

      return {
        success: true,
        message: 'QR code verified successfully',
        submission: formattedSubmission,
      };

    } catch (error) {
      logger.error('QRService', 'Error verifying QR code', error, { qrString: data.qrString });
      throw error;
    }
  }

  /**
   * Check if same user has already scanned this submission today
   */
  private static async checkDuplicateScanToday(submissionId: string, scannedBy: string) {
    try {
      // Get today's date range (Jakarta timezone)
      const jakartaNow = new Date().toLocaleString('en-US', { timeZone: 'Asia/Jakarta' });
      const today = new Date(jakartaNow);
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
      const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59, 999);
      
      const existingScan = await prisma.qrScan.findFirst({
        where: {
          submission_id: submissionId,
          scanned_by: scannedBy,
          scanned_at: {
            gte: startOfDay,
            lte: endOfDay,
          }
        },
        include: {
          user: {
            select: {
              officer_name: true,
            },
          },
        },
      });

      return existingScan;
    } catch (error) {
      logger.error('QRService', 'Error checking duplicate scan', error);
      return null;
    }
  }

  /**
   * Get scan history for a submission
   */
  static async getScanHistory(submissionId: string, limit: number = 50) {
    try {
      const scans = await prisma.qrScan.findMany({
        where: { submission_id: submissionId },
        include: {
          user: {
            select: {
              id: true,
              officer_name: true,
              email: true,
              role: true,
            }
          }
        },
        orderBy: {
          scanned_at: 'desc'
        },
        take: limit,
      });

      // Format dates
      const formattedScans = scans.map(scan => ({
        ...scan,
        scanned_at: toJakartaISOString(scan.scanned_at) || scan.scanned_at,
      }));

      logger.info('QRService', 'Scan history retrieved', {
        submissionId,
        count: scans.length,
      });

      return formattedScans;
    } catch (error) {
      logger.error('QRService', 'Error getting scan history', error, { submissionId });
      throw error;
    }
  }

  /**
   * Get scan statistics for a verifier
   */
  static async getVerifierStats(verifierId: string, startDate?: Date, endDate?: Date) {
    try {
      const whereClause: any = {
        scanned_by: verifierId,
      };

      if (startDate || endDate) {
        whereClause.scanned_at = {};
        if (startDate) whereClause.scanned_at.gte = startDate;
        if (endDate) whereClause.scanned_at.lte = endDate;
      }

      const [totalScans, uniqueSubmissions] = await Promise.all([
        prisma.qrScan.count({ where: whereClause }),
        prisma.qrScan.findMany({
          where: whereClause,
          select: { submission_id: true },
          distinct: ['submission_id'],
        }),
      ]);

      logger.info('QRService', 'Verifier stats retrieved', {
        verifierId,
        totalScans,
        uniqueSubmissions: uniqueSubmissions.length,
      });

      return {
        totalScans,
        uniqueSubmissions: uniqueSubmissions.length,
        averageScansPerSubmission: uniqueSubmissions.length > 0 
          ? (totalScans / uniqueSubmissions.length).toFixed(2) 
          : 0,
      };
    } catch (error) {
      logger.error('QRService', 'Error getting verifier stats', error, { verifierId });
      throw error;
    }
  }
}

export default QRService;
