import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/singletons';
import { parseQrString, type QrPayload } from '@/lib/qr-security';
import { toJakartaISOString } from '@/lib/timezone';
import { responseCache, CacheTTL, CacheTags, generateCacheKey } from '@/lib/response-cache';
import { parallelQueries } from '@/lib/db-optimizer';

// POST /api/qr/verify - Verify QR code and return submission data
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Only VERIFIER and ADMIN can scan QR codes/barcodes
    if (!['VERIFIER', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json({ 
        error: 'Access denied. Only verifiers and admins can scan QR codes/barcodes.' 
      }, { status: 403 });
    }

    const body = await request.json();
    const { qrData, qr_data, scanLocation, scanner_type } = body;

    // Support both qrData and qr_data parameter names for compatibility
    const qrString = qr_data || qrData;

    console.log('=== QR VERIFY API ===');
    console.log('Received qrString:', qrString);
    console.log('qrString length:', qrString?.length);
    console.log('scanner_type:', scanner_type);
    console.log('session.user:', session.user);
    console.log('session.user.id:', session.user.id);
    console.log('session.user.role:', session.user.role);
    console.log('====================');

    if (!qrString) {
      console.log('ERROR: No QR/Barcode string provided');
      return NextResponse.json({ 
        success: false,
        message: 'QR/Barcode string is required' 
      }, { status: 400 });
    }

    // Parse and verify QR code or barcode
    const qrPayload: QrPayload | null = parseQrString(qrString);
    
    console.log('=== QR PARSING RESULT ===');
    console.log('Parsed payload:', qrPayload);
    console.log('========================');
    
    if (!qrPayload) {
      console.log('ERROR: Failed to parse QR/Barcode');
      return NextResponse.json({ 
        success: false,
        message: 'Invalid QR code/barcode or data has been tampered with. Please make sure you are scanning a valid SIMLOK QR code or barcode generated by the system.' 
      }, { status: 400 });
    }

    // Check if QR/Barcode is valid for current date (simplified check)
    const now = Date.now();
    if (qrPayload.timestamp && now > qrPayload.timestamp + (7 * 24 * 60 * 60 * 1000)) { // 7 days validity
      return NextResponse.json({ 
        success: false,
        message: 'QR code/barcode has expired. Please generate a new one.' 
      }, { status: 400 });
    }

    // Fetch submission data
    const submission = await prisma.submission.findUnique({
      where: { id: qrPayload.id },
      include: {
        user: {
          select: {
            id: true,
            officer_name: true,
            email: true,
            vendor_name: true,
          }
        },
        worker_list: {
          select: {
            id: true,
            worker_name: true,
            worker_photo: true,
          },
          orderBy: {
            created_at: 'asc'
          }
        }
      }
    });

    if (!submission) {
      return NextResponse.json({ 
        success: false,
        message: 'Submission not found' 
      }, { status: 404 });
    }

    // Check if submission is approved
    if (submission.approval_status !== 'APPROVED') {
      return NextResponse.json({ 
        success: false,
        message: 'This submission is not approved yet' 
      }, { status: 400 });
    }

    // DEBUG: Check user session and database
    console.log('=== USER SESSION DEBUG ===');
    console.log('session.user:', JSON.stringify(session.user, null, 2));
    console.log('session.user.id:', session.user.id);
    
    // Check if this user exists in database
    const userExists = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true, email: true, role: true, officer_name: true, address: true }
    });
    console.log('userExists in DB:', userExists);
    
    if (!userExists) {
      console.log('ERROR: User not found in database');
      return NextResponse.json({ 
        success: false,
        message: 'User session is invalid. Please login again.' 
      }, { status: 401 });
    }

    // Check for duplicate scans - only prevent same verifier scanning same SIMLOK on same day
    console.log('=== CHECKING FOR DUPLICATE SCAN BY SAME VERIFIER ON SAME DAY ===');
    console.log('submission_id:', qrPayload.id);
    console.log('scanned_by:', session.user.id);
    
    // Get today's date range (start and end of day) using Jakarta timezone
    const jakartaNow = new Date().toLocaleString('en-US', { timeZone: 'Asia/Jakarta' });
    const today = new Date(jakartaNow);
    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
    const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59, 999);
    
    // Check if the same verifier has already scanned today
    const existingTodayScanByUser = await prisma.qrScan.findFirst({
      where: {
        submission_id: qrPayload.id,
        scanned_by: session.user.id,
        scanned_at: {
          gte: startOfDay,
          lte: endOfDay,
        }
      },
      include: {
        user: {
          select: {
            officer_name: true,
          },
        },
      },
    });

    console.log('existingTodayScanByUser found:', !!existingTodayScanByUser);

    if (existingTodayScanByUser) {
      console.log('=== DUPLICATE SCAN BY SAME USER TODAY DETECTED ===');
      const scanDate = new Date(existingTodayScanByUser.scanned_at);
      const formattedDate = scanDate.toLocaleDateString('id-ID', {
        day: '2-digit',
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      });

      return NextResponse.json({ 
        success: false, 
        error: 'duplicate_scan_same_day',
        message: `QR code sudah anda scan hari ini pada ${formattedDate}. Satu verifikator hanya dapat melakukan scan sekali per hari untuk SIMLOK yang sama.`,
        previousScan: {
          scanDate: existingTodayScanByUser.scanned_at,
          scanId: existingTodayScanByUser.id,
          scannerName: existingTodayScanByUser.user.officer_name,
        }
      }, { status: 409 });
    }

    // Note: Different verifiers CAN scan the same SIMLOK on the same day
    // This is allowed per the new requirements

    console.log('=== NO DUPLICATE FOUND, PROCEEDING TO CREATE SCAN RECORD ===');

    console.log('User verified for scan record creation:', userExists);

    // Record the scan in database
    try {
      const scanRecord = await prisma.qrScan.create({
        data: {
          submission_id: qrPayload.id,
          scanned_by: session.user.id,
          scanner_name: userExists.officer_name || session.user.officer_name,
          scan_location: scanLocation || userExists.address || 'Lokasi tidak tersedia',
        },
        include: {
          user: {
            select: {
              id: true,
              officer_name: true,
              email: true,
              role: true,
            }
          }
        }
      });

      console.log('=== SCAN RECORD CREATED SUCCESSFULLY ===');
      console.log('scanRecord.id:', scanRecord.id);

      // Return verification result with submission data in the format expected by the modal
      return NextResponse.json({
        success: true,
        message: 'QR code/barcode verified successfully',
  scan_id: scanRecord.id,
  scanned_at: toJakartaISOString(scanRecord.scanned_at) || scanRecord.scanned_at,
        scanned_by: scanRecord.user?.officer_name || session.user.officer_name,
        data: {
          submission: {
            id: submission.id,
            number: submission.simlok_number,
            title: submission.job_description,
            task: submission.implementation || 'No task description',
            workers: submission.worker_names.split('\n').filter(name => name.trim()).map(name => ({ name: name.trim() })),
            vendor: submission.vendor_name ? { name: submission.vendor_name } : undefined,
            location: submission.work_location || undefined,
            implementation_start_date: toJakartaISOString(submission.implementation_start_date) || submission.implementation_start_date,
            implementation_end_date: toJakartaISOString(submission.implementation_end_date) || submission.implementation_end_date,
            status: submission.approval_status.toLowerCase(),
          }
        }
      });

    } catch (createError: any) {
      console.error('Error creating scan record:', createError);
      
      // Check if it's a unique constraint violation (in case of race condition)
      if (createError?.code === 'P2002') {
        console.log('=== UNIQUE CONSTRAINT VIOLATION DETECTED (RACE CONDITION) ===');
        
        // Check again for today's scans by same user only (race condition handling) - use Jakarta time
        const jakartaNow = new Date().toLocaleString('en-US', { timeZone: 'Asia/Jakarta' });
        const today = new Date(jakartaNow);
        const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
        const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59, 999);
        
        const raceConditionScan = await prisma.qrScan.findFirst({
          where: {
            submission_id: qrPayload.id,
            scanned_by: session.user.id, // Only check for same user
            scanned_at: {
              gte: startOfDay,
              lte: endOfDay,
            }
          },
          include: {
            user: {
              select: {
                officer_name: true,
              },
            },
          },
        });

        if (raceConditionScan) {
          const scanDate = new Date(raceConditionScan.scanned_at);
          const formattedDate = scanDate.toLocaleDateString('id-ID', {
            day: '2-digit',
            month: '2-digit', 
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          });

          return NextResponse.json({ 
            success: false, 
            error: 'duplicate_scan_same_day',
            message: `Anda sudah melakukan scan untuk SIMLOK ini hari ini pada ${formattedDate}. Verifikator yang sama tidak dapat scan SIMLOK yang sama di hari yang sama.`
          }, { status: 409 });
        }

        return NextResponse.json({ 
          success: false, 
          error: 'duplicate_scan',
          message: 'QR Code ini sudah pernah discan hari ini (race condition detected)'
        }, { status: 409 });
      }
      
      throw createError; // Re-throw if it's not a constraint violation
    }

  } catch (error) {
    console.error('QR/Barcode verification error:', error);
    return NextResponse.json({ 
      success: false,
      message: 'Internal server error during QR/Barcode verification' 
    }, { status: 500 });
  }
}

// GET /api/qr/verify - Get recent scan history (for admin/verifier dashboard)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Only VERIFIER and ADMIN can view scan history
    if (!['VERIFIER', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json({ 
        error: 'Access denied. Only verifiers and admins can view scan history.' 
      }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 100);
    const offset = parseInt(searchParams.get('offset') || '0');
    const submissionId = searchParams.get('submission_id');
    const search = searchParams.get('search');
    const status = searchParams.get('status');
    const dateFrom = searchParams.get('dateFrom');
    const dateTo = searchParams.get('dateTo');
    const location = searchParams.get('location');

    // Build where clause
    const whereClause: any = {};
    
    if (submissionId) {
      whereClause.submission_id = submissionId;
    }

    // For verifiers, only show their own scans
    if (session.user.role === 'VERIFIER') {
      whereClause.scanned_by = session.user.id;
    }

    // Add search filter
    if (search) {
      whereClause.OR = [
        {
          submission: {
            simlok_number: {
              contains: search
            }
          }
        },
        {
          submission: {
            vendor_name: {
              contains: search
            }
          }
        },
        {
          scan_location: {
            contains: search
          }
        }
      ];
    }

    // Add status filter
    if (status) {
      whereClause.submission = {
        ...whereClause.submission,
        approval_status: status
      };
    }

    // Add date range filter
    if (dateFrom || dateTo) {
      whereClause.scanned_at = {};
      if (dateFrom) {
        whereClause.scanned_at.gte = new Date(dateFrom);
      }
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999); // End of day
        whereClause.scanned_at.lte = endDate;
      }
    }

    // Add location filter
    if (location) {
      whereClause.scan_location = {
        contains: location
      };
    }

    // Generate cache key
    const cacheKey = generateCacheKey('qr-scan-history', {
      role: session.user.role,
      userId: session.user.role === 'VERIFIER' ? session.user.id : 'all',
      limit,
      offset,
      submissionId,
      search,
      status,
      dateFrom,
      dateTo,
      location
    });

    // Check cache first (30 seconds TTL for recent scans)
    const cached = responseCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    // Fetch scan history and total count in parallel
    const [scans, totalCount] = await parallelQueries([
      () => prisma.qrScan.findMany({
        where: whereClause,
        include: {
          user: {
            select: {
              id: true,
              officer_name: true,
              email: true,
              role: true,
            }
          },
          submission: {
            select: {
              id: true,
              simlok_number: true,
              vendor_name: true,
              officer_name: true,
              job_description: true,
              work_location: true,
              approval_status: true,
            }
          }
        },
        orderBy: {
          scanned_at: 'desc'
        },
        take: limit,
        skip: offset,
      }),
      
      // Get total count in parallel
      () => prisma.qrScan.count({
        where: whereClause,
      })
    ]);

    // Format timestamps and nested submission dates to Jakarta
    const { formatScansDates, formatSubmissionDates } = await import('@/lib/timezone');
    const formattedScans = scans.map((s: any) => ({
      ...s,
      scanned_at: (s.scanned_at ? new Date(s.scanned_at) : null) ? formatScansDates([s])[0]!.scanned_at : s.scanned_at,
      submission: s.submission ? formatSubmissionDates(s.submission) : s.submission
    }));

    const response = NextResponse.json({
      scans: formattedScans,
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount,
      }
    });

    // Cache the response
    const userIdTag = session.user.role === 'VERIFIER' ? `verifier-${session.user.id}` : 'all-verifiers';
    responseCache.set(cacheKey, response, CacheTTL.SHORT, [CacheTags.QR_SCANS, userIdTag]);
    
    return response;

  } catch (error) {
    console.error('Scan history fetch error:', error);
    return NextResponse.json({ 
      error: 'Internal server error while fetching scan history' 
    }, { status: 500 });
  }
}
