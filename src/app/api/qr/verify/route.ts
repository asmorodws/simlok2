import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/singletons';
import { parseQrString, type QrPayload } from '@/lib/qr-security';

// POST /api/qr/verify - Verify QR code and return submission data
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Only VERIFIER and ADMIN can scan QR codes/barcodes
    if (!['VERIFIER', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json({ 
        error: 'Access denied. Only verifiers and admins can scan QR codes/barcodes.' 
      }, { status: 403 });
    }

    const body = await request.json();
    const { qrData, qr_data, scanLocation, scanNotes, scanner_type } = body;

    // Support both qrData and qr_data parameter names for compatibility
    const qrString = qr_data || qrData;

    console.log('=== QR VERIFY API ===');
    console.log('Received qrString:', qrString);
    console.log('qrString length:', qrString?.length);
    console.log('scanner_type:', scanner_type);
    console.log('====================');

    if (!qrString) {
      console.log('ERROR: No QR/Barcode string provided');
      return NextResponse.json({ 
        success: false,
        message: 'QR/Barcode string is required' 
      }, { status: 400 });
    }

    // Parse and verify QR code or barcode
    const qrPayload: QrPayload | null = parseQrString(qrString);
    
    console.log('=== QR PARSING RESULT ===');
    console.log('Parsed payload:', qrPayload);
    console.log('========================');
    
    if (!qrPayload) {
      console.log('ERROR: Failed to parse QR/Barcode');
      return NextResponse.json({ 
        success: false,
        message: 'Invalid QR code/barcode or data has been tampered with. Please make sure you are scanning a valid SIMLOK QR code or barcode generated by the system.' 
      }, { status: 400 });
    }

    // Check if QR/Barcode is valid for current date (simplified check)
    const now = Date.now();
    if (qrPayload.timestamp && now > qrPayload.timestamp + (7 * 24 * 60 * 60 * 1000)) { // 7 days validity
      return NextResponse.json({ 
        success: false,
        message: 'QR code/barcode has expired. Please generate a new one.' 
      }, { status: 400 });
    }

    // Fetch submission data
    const submission = await prisma.submission.findUnique({
      where: { id: qrPayload.id },
      include: {
        user: {
          select: {
            id: true,
            officer_name: true,
            email: true,
            vendor_name: true,
          }
        },
        approved_by_user: {
          select: {
            id: true,
            officer_name: true,
            email: true,
          }
        },
        worker_list: {
          select: {
            id: true,
            worker_name: true,
            worker_photo: true,
          },
          orderBy: {
            created_at: 'asc'
          }
        }
      }
    });

    if (!submission) {
      return NextResponse.json({ 
        success: false,
        message: 'Submission not found' 
      }, { status: 404 });
    }

    // Check if submission is approved
    if (submission.approval_status !== 'APPROVED') {
      return NextResponse.json({ 
        success: false,
        message: 'This submission is not approved yet' 
      }, { status: 400 });
    }

    // Record the scan in database
    const scanRecord = await prisma.qrScan.create({
      data: {
        submission_id: qrPayload.id,
        scanned_by: session.user.id,
        scanner_name: session.user.officer_name,
        notes: scanNotes || `Scanned via ${scanner_type || 'scanner'} at: ${scanLocation || 'Unknown location'}`,
      },
      include: {
        user: {
          select: {
            id: true,
            officer_name: true,
            email: true,
            role: true,
          }
        }
      }
    });

    // Return verification result with submission data in the format expected by the modal
    return NextResponse.json({
      success: true,
      message: 'QR code/barcode verified successfully',
      scan_id: scanRecord.id,
      scanned_at: scanRecord.scanned_at,
      scanned_by: scanRecord.user.officer_name,
      data: {
        submission: {
          id: submission.id,
          number: submission.simlok_number,
          title: submission.job_description,
          task: submission.implementation || 'No task description',
          workers: submission.worker_list.map(worker => ({ name: worker.worker_name })),
          vendor: submission.vendor_name ? { name: submission.vendor_name } : undefined,
          location: submission.work_location || undefined,
          implementation_start_date: submission.implementation_start_date?.toISOString(),
          implementation_end_date: submission.implementation_end_date?.toISOString(),
          status: submission.approval_status.toLowerCase(),
        }
      }
    });

  } catch (error) {
    console.error('QR/Barcode verification error:', error);
    return NextResponse.json({ 
      success: false,
      message: 'Internal server error during QR/Barcode verification' 
    }, { status: 500 });
  }
}

// GET /api/qr/verify - Get recent scan history (for admin/verifier dashboard)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Only VERIFIER and ADMIN can view scan history
    if (!['VERIFIER', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json({ 
        error: 'Access denied. Only verifiers and admins can view scan history.' 
      }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 100);
    const offset = parseInt(searchParams.get('offset') || '0');
    const submissionId = searchParams.get('submission_id');

    // Build where clause
    const whereClause: any = {};
    
    if (submissionId) {
      whereClause.submission_id = submissionId;
    }

    // For verifiers, only show their own scans
    if (session.user.role === 'VERIFIER') {
      whereClause.scanned_by = session.user.id;
    }

    // Fetch scan history
    const scans = await prisma.qrScan.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            officer_name: true,
            email: true,
            role: true,
          }
        },
        submission: {
          select: {
            id: true,
            simlok_number: true,
            vendor_name: true,
            officer_name: true,
            job_description: true,
            work_location: true,
            approval_status: true,
          }
        }
      },
      orderBy: {
        scanned_at: 'desc'
      },
      take: limit,
      skip: offset,
    });

    // Get total count
    const totalCount = await prisma.qrScan.count({
      where: whereClause,
    });

    return NextResponse.json({
      scans,
      pagination: {
        total: totalCount,
        limit,
        offset,
        hasMore: offset + limit < totalCount,
      }
    });

  } catch (error) {
    console.error('Scan history fetch error:', error);
    return NextResponse.json({ 
      error: 'Internal server error while fetching scan history' 
    }, { status: 500 });
  }
}
